/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * ServerMonitor.java
 *
 * Created on 28-Dec-2008, 00:21:02
 */

package ru.spbu.math.m04eiv.maths.server.ui;

import java.util.concurrent.Executors;

import ru.spbu.math.m04eiv.maths.common.tasks.TTaskExecutor;
import ru.spbu.math.m04eiv.maths.server.Server;
import ru.spbu.math.m04eiv.maths.server.ui.TasksListModel.TaskInfo;

import com.google.code.annatasha.annotations.Method.ExecPermissions;

/**
 * 
 * @author Ivan Egorov
 */
public class ServerMonitor extends javax.swing.JFrame {

	private final Server server;

	/** Creates new form ServerMonitor */
	public ServerMonitor() {
		server = new Server();
		initComponents();
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	private void initComponents() {

		jScrollPane1 = new javax.swing.JScrollPane();
		jTasksList = new javax.swing.JList();
		jKillButton = new javax.swing.JButton();

		setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

		jTasksList.setModel(new TasksListModel(server.getManager()));
		jTasksList.setCellRenderer(new TaskListCellRenderer());
		// jTasksList.setSelectionBackground(Color.BLUE);
		jScrollPane1.setViewportView(jTasksList);

		jKillButton.setText("Kill");
		jKillButton.addActionListener(new KillAction());

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(
				getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGroup(
				layout.createSequentialGroup().addComponent(jScrollPane1,
						javax.swing.GroupLayout.DEFAULT_SIZE, 298,
						Short.MAX_VALUE).addPreferredGap(
						javax.swing.LayoutStyle.ComponentPlacement.RELATED)
						.addComponent(jKillButton,
								javax.swing.GroupLayout.PREFERRED_SIZE, 84,
								javax.swing.GroupLayout.PREFERRED_SIZE)
						.addContainerGap()));
		layout.setVerticalGroup(layout.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addComponent(
				jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 312,
				Short.MAX_VALUE).addGroup(
				javax.swing.GroupLayout.Alignment.TRAILING,
				layout.createSequentialGroup().addContainerGap().addComponent(
						jKillButton).addGap(271, 271, 271)));

		pack();
	}

	private void jKillButtonActionPerformed(java.awt.event.ActionEvent evt) {
		final TasksListModel model = (TasksListModel) jTasksList.getModel();
		final int[] indices = jTasksList.getSelectedIndices();
		final TaskInfo[] ti = new TaskInfo[indices.length];

		for (int i = 0; i < indices.length; ++i) {
			ti[i] = (TaskInfo) model.getElementAt(indices[i]);
		}

		Executors.newSingleThreadExecutor().execute(new TasksKiller(ti));
	}

	private static final class UIThread implements UIRunnable {
		public void run() {
			ServerMonitor mon = new ServerMonitor();
			mon.start();
			mon.setVisible(true);
		}
	}

	private final class KillAction implements java.awt.event.ActionListener {
		public void actionPerformed(java.awt.event.ActionEvent evt) {
			jKillButtonActionPerformed(evt);
		}
	}

	private final static class TasksKiller implements Runnable, TTaskExecutor {
		private final TaskInfo[] tasksInfo;

		public TasksKiller(TaskInfo[] ti) {
			tasksInfo = ti;
		}

		@Override
		// @ExecPermissions(TTaskExecutor.class)
		public void run() {
			for (TaskInfo ti : tasksInfo) {
				ti.task.stop();
			}
		}

	}

	/**
	 * @param args
	 *            the command line arguments
	 */
	public static void main(String args[]) {
		java.awt.EventQueue.invokeLater(new UIThread());
	}

	private void start() {
		Executors.newSingleThreadExecutor().execute(server);
	}

	// Variables declaration - do not modify
	private javax.swing.JButton jKillButton;
	private javax.swing.JList jTasksList;
	private javax.swing.JScrollPane jScrollPane1;
	// End of variables declaration

}
